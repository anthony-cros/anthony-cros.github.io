<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Turning Scala code into Spark by Anthony Cros</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Anthony Cros' blog</h1>
      <h2 class="project-tagline">Informatique at its meilleur.</h2>
    </section>

    <section class="main-content">
      <h1>
<a id="turning-scala-code-into-spark" class="anchor" href="#turning-scala-code-into-spark" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Turning Scala code into Spark</h1>

<p><em>by Anthony Cros, September 19 2016</em></p>

<p>The other day I found myself explaining to a bioinformatician in our team how we could process some data at scale. She is mostly used to processing data in-memory due to the relative small size of the data she typically deals with, but this time we were going to have to leverage a cluster in order to make it happen. An HPC-based solution could also be used here, but would require more low-level manipulations<sup><a href="#hpc">[1]</a></sup>. The size of the data wasn't all that big, somewhere in the vicinity of 1TB, but just too big to fit in the most powerful machine we had handy. So I thought it'd be a good occasion to introduce her to <a href="http://spark.apache.org/">Apache Spark</a>. But because she was mostly used to processing data in an imperative manner (as opposed to <a href="http://programmers.stackexchange.com/questions/117092/whats-the-difference-between-imperative-procedural-and-structured-programming">declarative</a> here), I figured I would first show her what the processing flow would look like in <a href="http://www.scala-lang.org/">Scala</a><sup><a href="#scala-res">[2]</a></sup>. That way I would not introduce both a new computational paradigm <strong>and</strong> an entirely new framework at once.</p>

<hr>

<h3>
<a id="scala-approach" class="anchor" href="#scala-approach" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Scala approach</h3>

<p>The original task at hand, part of a <a href="https://www.standup2cancer.org/">Stand Up 2 Cancer</a> effort, consisted of turning a bunch of <em>CSV</em> files<sup><a href="#csv">[3]</a></sup> into a highly nested structure and annotating nested documents from various web services. The most important part was to do two nested <code>GROUP BYs</code>, so I only kept that part. I made up two dummy input files that vaguely resembled the original ones:</p>

<p><em>f1.tsv</em>:</p>

<pre><code>gene  sample  other1
g1    s1      a1
g1    s2      b1
g1    s3a     c1
g2    s4      d1
</code></pre>

<p>And</p>

<p><em>f2.tsv</em>:</p>

<pre><code>gene  sample  other21  other22
g1    s1      a21      a22
g1    s2      b21      b22
g1    s3b     c21      c22
g2    s4      d21      d22
g3    s5      f21      f22
</code></pre>

<p>And came up with the following <a href="https://github.com/anthony-cros/anthony-cros.github.io/blob/master/blog/turn-scala-into-spark/code/Scala.scala">Scala code</a>:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">package</span> <span class="pl-en">demo.scala</span>

<span class="pl-c">// intentionally verbose so it reads more easily</span>
<span class="pl-c">// shouldn't actually be all in one file either</span>
<span class="pl-c">// ===========================================================================</span>
<span class="pl-k">object</span> <span class="pl-en">Inputs</span> {

    <span class="pl-k">trait</span> <span class="pl-en">HasGene</span>   { <span class="pl-k">val</span> <span class="pl-en">gene</span><span class="pl-k">:</span>   <span class="pl-k">String</span> } 
    <span class="pl-k">trait</span> <span class="pl-en">HasSample</span> { <span class="pl-k">val</span> <span class="pl-en">sample</span><span class="pl-k">:</span> <span class="pl-k">String</span> }

    <span class="pl-k">sealed</span> <span class="pl-k">trait</span> <span class="pl-en">F</span>
      <span class="pl-k">extends</span> <span class="pl-e">HasGene</span>
         <span class="pl-k">with</span> <span class="pl-e">HasSample</span>

    <span class="pl-c">// ---------------------------------------------------------------------------</span>
    <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">F1</span>(
            <span class="pl-v">gene</span>:   <span class="pl-k">String</span>,
            <span class="pl-v">sample</span>: <span class="pl-k">String</span>,
            <span class="pl-v">other1</span>: <span class="pl-k">String</span>)
        <span class="pl-k">extends</span> <span class="pl-e">F</span>

        <span class="pl-k">object</span> <span class="pl-en">F1</span> {

            <span class="pl-k">def</span> <span class="pl-en">apply</span>(<span class="pl-v">line</span>: <span class="pl-k">String</span>)<span class="pl-k">:</span> <span class="pl-en">F1</span> <span class="pl-k">=</span> { <span class="pl-c">// factory of F1s</span>
                <span class="pl-k">val</span> <span class="pl-en">it</span> <span class="pl-k">=</span> line.split(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\t</span><span class="pl-pds">"</span></span>).iterator

                <span class="pl-en">F1</span>(
                    gene   <span class="pl-k">=</span> it.next, <span class="pl-c">// TODO: should add checks</span>
                    sample <span class="pl-k">=</span> it.next,
                    other1 <span class="pl-k">=</span> it.next)
            }

        }

    <span class="pl-c">// ---------------------------------------------------------------------------</span>
    <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">F2</span>(
            <span class="pl-v">gene</span>:    <span class="pl-k">String</span>,
            <span class="pl-v">sample</span>:  <span class="pl-k">String</span>,
            <span class="pl-v">other21</span>: <span class="pl-k">String</span>,
            <span class="pl-v">other22</span>: <span class="pl-k">String</span>)
        <span class="pl-k">extends</span> <span class="pl-e">F</span>

        <span class="pl-k">object</span> <span class="pl-en">F2</span> {

            <span class="pl-k">def</span> <span class="pl-en">apply</span>(<span class="pl-v">line</span>: <span class="pl-k">String</span>)<span class="pl-k">:</span> <span class="pl-en">F2</span> <span class="pl-k">=</span> { <span class="pl-c">// factory of F2s</span>
                <span class="pl-k">val</span> <span class="pl-en">it</span> <span class="pl-k">=</span> line.split(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\t</span><span class="pl-pds">"</span></span>).iterator

                <span class="pl-en">F2</span>(
                    gene    <span class="pl-k">=</span> it.next,
                    sample  <span class="pl-k">=</span> it.next,
                    other21 <span class="pl-k">=</span> it.next,
                    other22 <span class="pl-k">=</span> it.next)
            }

        }

}

<span class="pl-c">// ===========================================================================</span>
<span class="pl-k">object</span> <span class="pl-en">Outputs</span> {

  <span class="pl-k">import</span> <span class="pl-v">Inputs.</span><span class="pl-v">_</span>

    <span class="pl-c">// ---------------------------------------------------------------------------</span>
    <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">GeneCentric</span>(
            <span class="pl-v">gene</span>: <span class="pl-k">String</span>,
            <span class="pl-v">samples</span>: <span class="pl-en">Iterable</span>[<span class="pl-en">SampleCentric</span>])

    <span class="pl-c">// ---------------------------------------------------------------------------</span>
    <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">SampleCentric</span>(
        <span class="pl-v">sample</span>: <span class="pl-k">String</span>,
        <span class="pl-v">extras</span>: <span class="pl-en">Iterable</span>[<span class="pl-en">Extra</span>])

    <span class="pl-c">// ---------------------------------------------------------------------------</span>
    <span class="pl-k">sealed</span> <span class="pl-k">trait</span> <span class="pl-en">Extra</span>

        <span class="pl-k">object</span> <span class="pl-en">Extra</span> {

            <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Extra1</span>(
                  <span class="pl-v">other1</span>: <span class="pl-k">String</span>)
                <span class="pl-k">extends</span> <span class="pl-e">Extra</span>

            <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Extra2</span>(
                <span class="pl-v">other21</span>: <span class="pl-k">String</span>,
                <span class="pl-v">other22</span>: <span class="pl-k">String</span>)
                <span class="pl-k">extends</span> <span class="pl-e">Extra</span>

            <span class="pl-c">// factory of "extras" (either as Extra1 or Extra2,</span>
            <span class="pl-c">// based on the type of f we get)</span>
            <span class="pl-k">def</span> <span class="pl-en">apply</span>(<span class="pl-v">f</span>: <span class="pl-en">F</span>)<span class="pl-k">:</span> <span class="pl-en">Extra</span> <span class="pl-k">=</span>
                <span class="pl-c">// this pattern matching is safe because F is sealed</span>
                <span class="pl-c">// (compiler will warn if we forget a case)</span>
                <span class="pl-c">// pattern matching is one of the most powerful scala constructs, see</span>
                <span class="pl-c">// http://alvinalexander.com/scala/using-match-expression-like-switch-statement</span>
                f <span class="pl-k">match</span> {               
                    <span class="pl-k">case</span> <span class="pl-en">F1</span>(_, _, other1) <span class="pl-k">=&gt;</span>           <span class="pl-en">Extra1</span>(other1)
                    <span class="pl-k">case</span> <span class="pl-en">F2</span>(_, _, other21, other22) <span class="pl-k">=&gt;</span> <span class="pl-en">Extra2</span>(other21, other22)
                }

        }

}

<span class="pl-c">// ===========================================================================</span>
<span class="pl-k">object</span> <span class="pl-en">Demo</span> <span class="pl-k">extends</span> <span class="pl-e">App</span> { <span class="pl-c">// i.e. main ("App" trait)</span>

    <span class="pl-k">import</span> <span class="pl-v">Inputs.</span><span class="pl-v">_</span>
    <span class="pl-k">import</span> <span class="pl-v">Outputs.</span><span class="pl-v">_</span>
    <span class="pl-k">import</span> <span class="pl-v">Outputs.Extra.</span><span class="pl-v">_</span>

    <span class="pl-c">// ---------------------------------------------------------------------------</span>
    <span class="pl-c">// These are simply type aliases used for illustration purposes here</span>
    <span class="pl-k">type</span> <span class="pl-en">GenericSeq</span>[<span class="pl-en">A</span>]      <span class="pl-k">=</span> <span class="pl-en">Seq</span>[<span class="pl-en">A</span>]
    <span class="pl-k">type</span> <span class="pl-en">GenericIterable</span>[<span class="pl-en">A</span>] <span class="pl-k">=</span> <span class="pl-en">Iterable</span>[<span class="pl-en">A</span>]

    <span class="pl-c">// ---------------------------------------------------------------------------</span>
    <span class="pl-c">// read lines and transform each into a F1/F2</span>
    <span class="pl-c">// "apply()" is an implicit factory that case classes all have</span>
    <span class="pl-k">val</span> <span class="pl-en">f1s</span><span class="pl-k">:</span> <span class="pl-en">GenericSeq</span>[<span class="pl-en">F</span>] <span class="pl-k">=</span> readIn(args(<span class="pl-c1">0</span>)).map(<span class="pl-en">F1</span>.apply)
    <span class="pl-k">val</span> <span class="pl-en">f2s</span><span class="pl-k">:</span> <span class="pl-en">GenericSeq</span>[<span class="pl-en">F</span>] <span class="pl-k">=</span> readIn(args(<span class="pl-c1">1</span>)).map(<span class="pl-en">F2</span>.apply)

    <span class="pl-c">// ---------------------------------------------------------------------------</span>
    <span class="pl-k">val</span> <span class="pl-en">genes</span><span class="pl-k">:</span> <span class="pl-en">GenericSeq</span>[(<span class="pl-k">String</span> <span class="pl-c">/* genes */</span>, <span class="pl-en">Map</span>[<span class="pl-k">String</span> <span class="pl-c">/* sample */</span>, <span class="pl-en">Iterable</span>[<span class="pl-en">F</span>]])] <span class="pl-k">=</span>
        f1s

            <span class="pl-c">// combine both file contents</span>
            .union(f2s)

            <span class="pl-c">// group by "gene" since they both are guaranteed</span>
            <span class="pl-c">// to have this property (they transitively extend HasGene via F)</span>
            .groupBy(f <span class="pl-k">=&gt;</span> f.gene)

            <span class="pl-c">// ignore key for now and focus on values (the groupings)</span>
            .mapValues(geneGroup <span class="pl-k">=&gt;</span>
                geneGroup

                    <span class="pl-c">// within each such grouping,</span>
                    <span class="pl-c">// do the same thing but with "sample" </span>
                    .groupBy(f <span class="pl-k">=&gt;</span> f.sample))
            .toSeq

    <span class="pl-c">//---------------------------------------------------------------------------</span>
    <span class="pl-k">val</span> <span class="pl-en">geneCentrics</span><span class="pl-k">:</span> <span class="pl-en">GenericIterable</span>[<span class="pl-en">GeneCentric</span>] <span class="pl-k">=</span>
        genes
            .map { <span class="pl-k">case</span> (genes, samples) <span class="pl-k">=&gt;</span> genes <span class="pl-k">-</span><span class="pl-k">&gt;</span>
                samples
                    .mapValues(f <span class="pl-k">=&gt;</span>

                        <span class="pl-c">// lastly extract last bits of interest</span>
                        f.map(<span class="pl-en">Extra</span>.apply))

                    <span class="pl-c">// we can now build the sample-centric object</span>
                    <span class="pl-c">// (does not capture the parent gene, though it could)</span>
                    <span class="pl-c">// note that this uses a scala trick to be able to pass</span>
                    <span class="pl-c">// a tuple to the primary constructor</span>
                    .map((<span class="pl-en">SampleCentric</span>.apply _).tupled) }

            <span class="pl-c">// we can now build the gene-centric object</span>
            .map((<span class="pl-en">GeneCentric</span>.apply _).tupled)

    <span class="pl-c">// ---------------------------------------------------------------------------</span>
    <span class="pl-c">// write all as giant json array</span>
    <span class="pl-k">val</span> <span class="pl-en">fw</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">java.io.FileWriter</span>(<span class="pl-s"><span class="pl-pds">"</span>/tmp/demo.json<span class="pl-pds">"</span></span>)
        fw.write( <span class="pl-c">// TODO: a scalable solution should stream instead</span>
                geneCentrics
                    .map(geneCentric <span class="pl-k">=&gt;</span>
                            net.liftweb.json.<span class="pl-en">Serialization</span>.writePretty
                                (geneCentric)
                                (net.liftweb.json.<span class="pl-en">DefaultFormats</span>))
                    .mkString(<span class="pl-s"><span class="pl-pds">"</span>[<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>,<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>]<span class="pl-pds">"</span></span>))
            fw.close()

    println(<span class="pl-s"><span class="pl-pds">"</span>done.<span class="pl-pds">"</span></span>)

  <span class="pl-c">// ===========================================================================</span>
  <span class="pl-k">def</span> <span class="pl-en">readIn</span>(<span class="pl-v">filePath</span>: <span class="pl-k">String</span>)<span class="pl-k">:</span> <span class="pl-en">GenericSeq</span>[<span class="pl-k">String</span>] <span class="pl-k">=</span>
    scala.io.<span class="pl-en">Source</span>
          .fromFile(filePath) <span class="pl-c">// TODO: should actually be closed</span>
            .getLines()
            .drop(<span class="pl-c1">1</span>) <span class="pl-c">// drop header (TODO: ideally would read schema from it)</span>
            .toSeq <span class="pl-c">// TODO: a scalable solution should stream instead</span>

}</pre></div>

<p>The code produces the following JSON ouput (slightly reformatted, order not guaranteed):</p>

<div class="highlight highlight-source-json"><pre>[{
  <span class="pl-s"><span class="pl-pds">"</span>gene<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>g3<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>samples<span class="pl-pds">"</span></span>:[
    {
      <span class="pl-s"><span class="pl-pds">"</span>sample<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>s5<span class="pl-pds">"</span></span>,
      <span class="pl-s"><span class="pl-pds">"</span>extras<span class="pl-pds">"</span></span>:[
        { <span class="pl-s"><span class="pl-pds">"</span>other21<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>f21<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>other22<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>f22<span class="pl-pds">"</span></span> } ]
    }
  ]
},{
  <span class="pl-s"><span class="pl-pds">"</span>gene<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>g2<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>samples<span class="pl-pds">"</span></span>:[
    {
      <span class="pl-s"><span class="pl-pds">"</span>sample<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>s4<span class="pl-pds">"</span></span>,
      <span class="pl-s"><span class="pl-pds">"</span>extras<span class="pl-pds">"</span></span>:[
        { <span class="pl-s"><span class="pl-pds">"</span>other1<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>d1<span class="pl-pds">"</span></span> },
        { <span class="pl-s"><span class="pl-pds">"</span>other21<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>d21<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>other22<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>d22<span class="pl-pds">"</span></span> }
      ]
    }
  ]
},{
  <span class="pl-s"><span class="pl-pds">"</span>gene<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>g1<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>samples<span class="pl-pds">"</span></span>:[
    {
      <span class="pl-s"><span class="pl-pds">"</span>sample<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>s2<span class="pl-pds">"</span></span>,
      <span class="pl-s"><span class="pl-pds">"</span>extras<span class="pl-pds">"</span></span>:[
        { <span class="pl-s"><span class="pl-pds">"</span>other1<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>b1<span class="pl-pds">"</span></span> },
        { <span class="pl-s"><span class="pl-pds">"</span>other21<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>b21<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>other22<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>b22<span class="pl-pds">"</span></span> }
      ]
    },
    {
      <span class="pl-s"><span class="pl-pds">"</span>sample<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>s1<span class="pl-pds">"</span></span>,
      <span class="pl-s"><span class="pl-pds">"</span>extras<span class="pl-pds">"</span></span>:[
        { <span class="pl-s"><span class="pl-pds">"</span>other1<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>a1<span class="pl-pds">"</span></span> },
        { <span class="pl-s"><span class="pl-pds">"</span>other21<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>a21<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>other22<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>a22<span class="pl-pds">"</span></span> }
      ]
    },
    {
      <span class="pl-s"><span class="pl-pds">"</span>sample<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>s3b<span class="pl-pds">"</span></span>,
      <span class="pl-s"><span class="pl-pds">"</span>extras<span class="pl-pds">"</span></span>:[
        { <span class="pl-s"><span class="pl-pds">"</span>other21<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>c21<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>other22<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>c22<span class="pl-pds">"</span></span> } ]
    },
    {
      <span class="pl-s"><span class="pl-pds">"</span>sample<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>s3a<span class="pl-pds">"</span></span>,
      <span class="pl-s"><span class="pl-pds">"</span>extras<span class="pl-pds">"</span></span>:[
        { <span class="pl-s"><span class="pl-pds">"</span>other1<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>c1<span class="pl-pds">"</span></span> } ]
    }
  ]
}]</pre></div>

<p>Now obviously the above code would be <strong>way</strong> overkill for such a trivial task, but I also thought it had value in showing the <a href="https://twitter.github.io/scala_school/type-basics.html">strength</a> of the Scala <a href="https://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/">type system</a><sup><a href="#static">[4]</a></sup>. If one pays close attention to the code, the <code>readIn</code> method and its call-sites are really the <strong>only</strong> places where a runtime error can actually happen. The rest is guaranteed safe by the compiler. Now it doesn't guarantee that the program is semantically correct, but it guarantees that we've wired the various entities in a compatible manner. So the idea is to imagine how this could be part of a much more complex pipeline, where having such compile-time support would really pay dividends (otherwise I still like a good old <em>python</em> or <em>groovy</em> script for such simpler tasks).</p>

<p>So after walking her through that Scala code, it seems she was able to understand roughly how the different pieces fit together. She was still a bit unsettled by this new way of thinking about computation, but seemed to see the value in a more declarative approach to data processing.</p>

<p>The next logical step was to show her the Spark equivalent, albeit with its Scala API since I'm not as a familiar with the python one. All that would be left for her to do was to "translate" it to the python API, since that's the language she was most comfortable with. So I set out to rewrite the code with Spark. But slowly I starting feeling like I was replicating nearly exactly what I had just written in Scala... So upon completion, I tried reorganizing my Spark code in order to make it resemble the Scala one. And that's when it really struck me, how similar Scala collections and Spark really are... I was aware of the <a href="http://www.slideshare.net/SparkSummit/spark-the-ultimate-scala-collections-by-martin-odersky">similarities</a>, but it's not until I finished this little exercise that I realized how much so!<sup><a href="#google">[5]</a></sup></p>

<p>So for the rest of this post, I propose to walk you through the few steps required to turn the above Scala code into Spark code that can run locally (not all that useful for big computation but that's beside the point here).</p>

<hr>

<h3>
<a id="spark-approach" class="anchor" href="#spark-approach" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Spark approach</h3>

<p>Here is the <a href="https://github.com/anthony-cros/anthony-cros.github.io/blob/master/blog/turn-scala-into-spark/code/Spark.scala">Resulting file</a> diffed with the original file:
<br>
<br>
<img src="images/diff.png?token=AAAAxIauyaf3ZluOJcdl8_93vGtC0THUks5X4XQvwA%3D%3D" height="2000" width="1000"></p>

<p>Let's walk through the differences.</p>

<p>At the top, we need to import the relevant Spark entities:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">import</span> <span class="pl-v">org.apache.</span><span class="pl-v">spark</span>
<span class="pl-k">import</span> <span class="pl-v">org.apache.spark.</span>{<span class="pl-v">SparkContext</span>,<span class="pl-v">SparkConf</span>}
<span class="pl-k">import</span> <span class="pl-v">org.apache.spark.rdd.</span><span class="pl-v">RDD</span></pre></div>

<p>We then need to change the collection type of the - admittedly contrieved - collection aliases I created for illustration purposes:</p>

<div class="highlight highlight-source-diff"><pre><span class="pl-md">- type GenericSeq[A]      = Seq[A]</span>
<span class="pl-mi1">+ type GenericSeq[A]      = RDD[A]</span>
<span class="pl-md">- type GenericIterable[A] = Iterable[A]</span>
<span class="pl-mi1">+ type GenericIterable[A] = RDD[A]</span></pre></div>

<p>Then we need to add a <code>SparkContext</code> like so:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">sc</span> <span class="pl-k">=</span>
  <span class="pl-k">new</span> <span class="pl-en">spark.SparkContext</span>(
    <span class="pl-k">new</span> <span class="pl-en">spark.SparkConf</span>()
      .setAppName(<span class="pl-s"><span class="pl-pds">"</span>demo<span class="pl-pds">"</span></span>)
      .setMaster(<span class="pl-s"><span class="pl-pds">"</span>local<span class="pl-pds">"</span></span>))</pre></div>

<p>A little bit of cheating to compensate for the fact that Spark uses sequences of tuples instead of maps:</p>

<div class="highlight highlight-source-diff"><pre><span class="pl-md">- .toSeq</span></pre></div>

<p>A way to collect the result, i.e. actually triggering the workflow (which up until then is only a "plan of action"):</p>

<div class="highlight highlight-source-diff"><pre><span class="pl-mi1">+ .collect()</span></pre></div>

<p>Lastly we need to change how the files are being read in:</p>

<div class="highlight highlight-source-diff"><pre>    def readIn(filePath: String): GenericSeq[String] =
<span class="pl-md">-       io.Source</span>
<span class="pl-md">-           .fromFile(filePath) // TODO: close</span>
<span class="pl-md">-           .getLines()</span>
<span class="pl-md">-           .drop(1) // drop header</span>
<span class="pl-md">-           .toSeq</span>
<span class="pl-mi1">+       sc</span>
<span class="pl-mi1">+           .textFile(filePath)</span>
<span class="pl-mi1">+           // not quite as clean as the Scala version</span>
<span class="pl-mi1">+           // but I didn't want to complicate things too much here</span>
<span class="pl-mi1">+           .filter(!_.startsWith("gene\t")) </span></pre></div>

<p>Et voilà !<sup><a href="#french">[6]</a></sup></p>

<hr>

<h3>
<a id="conclusion" class="anchor" href="#conclusion" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Conclusion</h3>

<p>As you can see, 90% of the lines are the same, verbatim. And obviously, it produces the same result (order aside)!</p>

<p>In an upcoming post, I will show a significantly more compact way to express the same computation in Scala, though obviously at the expense of readability and scalability. I will then compare it to a python equivalent and comment on the relative sizes and merits of each<sup><a href="#compact">[7]</a></sup>.</p>

<p>Now I recognize that Scala is far from the easiest language to deal with, and that many things could be done to bolster its adoption in bioinformatics<sup><a href="#upcoming">[8]</a></sup>, but one has to admit that turning the above code into a scalable equivalent in just a few line changes is rather impressive!</p>

<p>Anyway, I thought it would be a good way to kickstart this blog :)</p>

<p>Feel free to share your <b>comments</b>/suggest corrections and improvements in the <a href="https://github.com/anthony-cros/anthony-cros.github.io/issues/1">github issue</a> I created for that purpose<sup><a href="#comments">[9]</a></sup>.</p>

<p><br>
<strong><em>Anthony Cros</em></strong>
<br>  @ <a href="http://dbhi.chop.edu/bioinformatics.html">The Bioinformatics Group</a>
<br>    @ <a href="http://dbhi.chop.edu/">The Department of Biomedical and Health Informatics</a>
<br>      @ <a href="http://dbhi.chop.edu/">The Children's Hospital of Philadelphia</a></p>

<p>A big thank you to the people who were nice enough to review the post, in alphabetical order: Emilie Lalonde, Pichai Raman, Deanne Taylor and Bob Tiernay.</p>

<p><br></p>

<hr>

<p><em>Footnotes</em>:</p>

<ul>
<li>
<a name="hpc"></a>[1] The kind I would like bioinformaticians in our team not to have to deal with: they have precious knowledge I'd rather see applied to solve new problems rather than reinventing the wheel every time.</li>
<li>
<a name="scala-res"></a>[2] See also the excellent <a href="https://twitter.github.io/scala_school/">Twitter Scala Schools</a> and <a href="http://danielwestheide.com/">Daniel Westheide</a>'s <a href="http://danielwestheide.com/scala/neophytes.html">Neophyte's Guide to Scala</a> as learning resources</li>
<li>
<a name="csv"></a>[3] Bioinformaticians sure like their <em>CSV</em> files!</li>
<li>
<a name="static"></a>[4] Not the most diplomatic case for it but still valuable.</li>
<li>
<a name="google"></a>[5] I had googled it around first and found relatively little guidance on the matter.</li>
<li>
<a name="french"></a>[6] I'm actually French, so it's legit.</li>
<li>
<a name="compact"></a>[7] It is possible to write very compact Scala code, though I tend to find that it defeats its purpose if overused.</li>
<li>
<a name="upcoming"></a>[8] See upcoming post (in the works, I'll link from here once it's ready).</li>
<li>
<a name="comments"></a>[9] I'm hoping to turn this into a proper blog soon, but this will have to do at first.</li>
</ul>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.research.chop.edu/DAMTEAM/sandbox">Blog</a> maintained by <a href="https://github.com/anthony-cros">Anthony Cros</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using a slighly modified version of the beautiful <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a> along with colors from <a href="http://uigradients.com/">uiGradients</a> by <a href="https://twitter.com/_ighosh">Indrashish Ghosh</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
